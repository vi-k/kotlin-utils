Kotlin-модуль `parser` содержит класс `Parser` для хранения состояния при парсинге.

# Содержание модуля:
- [Parser](#parser)
- [StringParser](#stringparser)
- [StringParserEx](#stringparserex)

# Parser

Класс `Parser` универсален. Он служит только для хранения состояния и паремещения по некоторому абстрактному списку. А что это на самом деле - список, массив, строка или ещё что-то - его не интересует.

## Переменные

Класс содержит три переменных-состояния:
- `start: Int` - для запоминания позиции, где был начат парсинг
- `pos: Int` - текущая позиция парсинга (позиция, где был закончен последний парсинг и где должен начаться следующий парсинг)
- `end: Int` - граница парсинга

## Конструктор

- `Parser(start, end)`

## Функции

- `reset()` - сброс состояния (и `start`, и `pos`) в 0.
- `reset(start)` - сброс состояния (и `start`, и `pos`) в позицию `start`.
- `start()` - пометка начала парсинга: `start` перемещается в позицию `pos`. Функция возвращает новую позицию `start`.
- `eof()` - проверка на достижение конца списка.
- `next()` - перемещение `pos` в следующую позицию. Проверка на достижение конца списка при этом **не осуществляется**!
- `back()` - возврат `pos` назад на одну позицию. Проверка на выход за какие-либо границы при этом **не осуществляется**!
- `parsed()` - проверка, был ли осуществлён парсинг. Возвращает `true`, если `pos` не равен `start`.
- `parsed(start)` - тоже, что и функция `parsed()` без параметров, только с позвращением позиции `start` в ранее самостоятельно сохранённое состояние. Это актуально, когда функция парсинга осуществляет вызов вложенных функций парсинга, которые также меняют позицию начала парсинга, вызывая функцию `start()`. Обычно работа `start()` и `parsed(start)` выглядит так:
    ```kotlin
    val parseStart = parser.start()
    ... // Вызов вложенных функций парсинга, меняющих позицию `start`
    return parser.parsed(parseStart)
    ```

# StringParser

Класс `StringParser` добавляет функциональности классу `Parser` при работе со строками.

## Переменные

Добавлена ещё одна переменная-состояние:
- `source: CharSequence` для хранения ссылки на обрабатываемую строку.

## Конструктор

- `StringParser(source, [start[, end]])` - параметр `end`, если не указан, устанавливается на конец строки (`source.length()`), параметр `start` - на начало строки.

## Функции

- `get()` - чтение символа, находящегося в текущей позиции.
- `get(index)` (или `parser[index]`) - доступ к любому символу строки по индексу.
- `getAndNext()` - чтение символа в текущей позиции и перемещение в следующую.
- `getParsed()` - копирование участка, над которым был произведён парсинг (участок между `start` и `pos`), в `String`.
- `getString([start[, end]])` - копирование указанного участка между параметрами `start` и `end` в `String`. Параметр `end`, если не указан, устанавливается в позицию `pos`. Параметр `start` - в позицию `start`. Если оба параметра опущены, функция становится аналогична функции `getParsed()`

> Обратите внимание, что указанные выше функции не проверяют выход за пределы парсинга! Делайте это самостоятельно через вызов `eof()`!

## Парсинг

> В отличие от предыдущих функций, функции парсинга проверяют выход за пределы строки.

- `parseChar(char)` - парсинг заданного символа. Если символ `char` обнаружен, `pos` сдвигается в следующую позицию, функция возвращает `true`. Если символ `char` не обнаружен, `pos` не меняется, функция возвращает `false`. Пример:
    ```kotlin
    val parser = StringParser(string)
    ...
    var parseStart = parser.start()
    while (parser.parseChar(' ')) {
        // Пустой блок! Просто пропускаем все пробелы
    }
    val count = parser.pos - parseStart // Кол-во пропущенных пробелов
    ```
- `parseNoChar(char)` - как и `parseChar()`, только перемещение происходит, если символ `char`, наоборот, не обнаружен. Пример в продолжение предыдущего:
    ```kotlin
    parseStart = parser.start()
    while (parser.parseNoChar(' ')) {
        // Пустой блок! Просто ищем слово между пробелами
    }
    parser.parsed(parseStart) // Восстанавливаем сохранённую позицию start, т.к. parseNoChar() её сдвинул
    val word = parser.getParsed() // Копируем в word слово между пробелами
    // Или вместо двух последних строчек, если нужно только найденное слово и нет необходимости восстанавливать позицию `start`:
    val word = parser.getString(parseStart) // Копируем в word слово между пробелами
    ```
- `parseDigits()` - парсинг десятичного числа (символы `[0..9]`) в строке. Если число присутствует, `pos` смещается на конец числа, функция возвращает `Int`. Если число не найдено, `pos` не меняется, функция возвращает `0`.
- `parseHexDigits()` - парсинг шестнадцатиричного числа (символы `[0-9a-fA-F]`). Остальное аналогично функции `parseDigits()`.

# StringParserEx

Главное отличие класса `StringParserEx` от `StringParser` только в одном - добавлена open-функция `isSpace(char)`. Функция эквивалентна вызову `Character.isSpaceChar(char)`, но имеет возможность переопределения (override) наследниками, если они не желают признавать за пробелы всё, что определено за таковые стандартом Unicode. Именно так обстоят дела с HTML - в нём свои символы-пробелы (в [`HtmlParser`](html#HtmlParser) функция `isSpace()` переопределена).

## Переменные

Новых переменных нет.

## Конструктор

Такой же, что в `StringParser`.

## Функции

- `isSpace(char)` - описана выше.

Также добавлены функции, зависящие от `isSpace()`:
- `trimStart(str)` - удаление пробелов в начале строки.
- `trimEnd(str)` - удаление пробелов в конце строки.
- `trim(str)` - удаление пробелов и в начале, и в конце строки.
- `parseSpace()` - парсинг пробела. Если пробел обнаружен, `pos` сдвигается в следующую позицию, функция возвращает `true`. Если пробел не обнаружен, `pos` не меняется, функция возвращает `false`.
- `parseSpaces()` - парсинг пробелов. Функция возвращает `true`, если пробелы обнаружены, `pos` в этом случае перемещается на ближайший символ не-пробел. Повторяет весь пример для функции `StringParser.parseChar()`.
- `parseNoSpace()` - парсинг не-пробела. В остальном как `parseSpace()`.
- `parseNoSpaces()` - парсинг не-пробелов. В остальном как `parseSpaces()`. Повторяет пример для функции `StringParser.parseNoChar()`.
